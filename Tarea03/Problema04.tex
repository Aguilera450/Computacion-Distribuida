%%%%%%%%%%% Aquí va la solución al problema 4.
\newpage
\textbf{\textcolor{MidnightBlue}{4.}}
Describe un algoritmo distribuido para construir un árbol generador sobre una gráfica
arbitraria G, utilizando el algoritmo de elección de líder eligeLider para determinar la raíz del
árbol y también el algoritmo BFS. Analiza la complejidad de tiempo y de mensajes.

\begin{algorithm}
\caption{arbolGeneradorConBFS(ID,total)}\label{alg:cap}
\begin{algorithmic}[1]

\State $PADRE = \bot, HIJOS = \emptyset, OTROS= \emptyset$
\State $LIDER = \bot$

\State Si no he recibido algún mensaje y no he decidido el lider
    \If{$LIDER == \bot \ \ and \ \ PADRE == \bot$} \Comment{Algorimo eligeLider}
        \State $LIDER = ID, ronda = 0$

        \State Ejecutar en todo momento $t \geq 0$
        \State $send<LIDER>$ a todos los vecinos
        \State Al recibir mensaje de todos los vecinos en tiempo $t \geq1 $
        \State $mensajes = \{<L_1>,<L_2>,...<L_d>\} \cup LIDER$
        \State $LIDER = Max(mensajes)$
        \State $ronda = ronda+1$

        \If{ronda == total} \Comment{Termina elección de lider}


        \If{$LIDER \ \ and \ \ PADRE == \bot$} \Comment{Algoritmo BFS}
        \State $send<BFS,ID>$ a todos mis vecinos
        \State PADRE = ID
    \EndIf

    \State Al recibir $<BFS,j>$ desde el vecino $p_j$:
        \If{$PADRE == \bot$}
            \State $Padre = j$
            \State $send(<parent>)$ a $p_j$
            \State $send(<BFS,ID>)$ a todos excepto $p_j$
        \Else
            \State $send(<already>)$ a $p_j$
        \EndIf
    \State Al recibir $<parent>$ desde el vecino $p_j$
    \State $HIJOS = HIJOS \cup \{p_j\}$

    \If{$HIJOS \cup OTROS == VECINOS-PADRE$}
        \State \textbf{Terminar}
    \EndIf

    \State Al recibir $<already>$ dede $p_j$
    \State $OTROS = OTROS \cup P_j$

    \If{$HIJOS \cup OTROS == VECINOS-PADRE$}
        \State \textbf{Terminar}
    \EndIf



        \EndIf
    \EndIf
    
\end{algorithmic}
\end{algorithm}

Analiza la complejidad de tiempo y de mensajes.

\textbf{Complejidad de tiempo}

Este algoritmo utiliza dos algoritmos:
\begin{enumerate}
    \item Primero eligeLider para elegir un lider, el cual utiliza una variable para contar el número de rondas que depende de $total$, ya que al final se tiene $total=ronda$ por lo tanto su complejidad en tiempo es $total=n$ 

    \item En la segunda parte se utiliza el algoritmo BFS usando el LIDER que se eligio antes. 

    Al principio el LIDER le envia el mensaje $<BFS,ID>$ a todos su vecinos, los cuales pueden recibir:
    \begin{enumerate}
        \item $<BFS,ID>$, y si no tiene PADRE le envía un mensaje a sus vecinos y al nodo del que recibio el mensaje para convertirlo en su PADRE. Si tiene PADRE le envia un mensaje al nodo del que recibio el mensaje para avisarle.
        \item $<parent>$, verifica si ya ha visitado sus vecinos, si lo hizo termina el algoritmo.
        \item $<already>$, verifica si ya ha visitado sus vecinos, si lo hizo termina el algoritmo.
    \end{enumerate}
    Los casos descritos anteriormente se evaluan para cada nodo en $n$ en una ronda. Podemos pensar que el peor de los casos se tendrá que la gráfica es un camino y el LIDER está en el centro de manera que tarda la máxima distancia entre el LIDER y cualquier vértice de la gráfica, es decir, su complejidad es $O(diam(G))$
\end{enumerate} 

Por lo tanto la complejidad de tiempo de todo el algoritmo es $O(n+diam(G))$


\textbf{Complejidad de mensajes}

Este algoritmo utiliza dos algoritmos:
\begin{enumerate}
    \item Primero eligeLider para elegir un lider, el cual por cada nodo $total=n$ envia un mensaje $<LIDER>$ a todos sus vecinos, por tanto su complejidad es $sum_v n * deg(v) = O(n|E|)$
    \item En la segunda parte se utiliza el algoritmo BFS usando el LIDER que se eligio antes. De manera similar cada nodo $total=n$ envia el mensaje $<BFS,ID>$ a sus vecinos con la diferencia de que si ya tiene un padre se envia el mensaje, por tanto su complejidad es $\sum_v n * deg(v) = O(n|E|)$
\end{enumerate}

Por lo tanto la complejidad de mensajes de todo el algoritmo es $O(2n|E|)$
