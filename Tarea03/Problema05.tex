%%%%%%%%%%% Aquí va la solución al problema 5.
\newpage
\textbf{\textcolor{MidnightBlue}{5.}} El algoritmo puede mejorar su complejidad de tiempo si se ejecutan de forma paralela
los dos algoritmos anteriores, es decir, si se ejecuta la elección de líder y la construcción del árbol BFS. Da un algoritmo distribuido que realice esto y muestra que es correcto. Adicionalmente, compara la complejidad de tiempo respecto al algoritmo anterior.

\begin{algorithm}
    \caption{arbolGenerador (ID,total)}\label{alg:cap}
    \begin{algorithmic}[1]
        \State $PADRE = \bot, \ \ HIJOS = \emptyset, \ \ OTROS = \emptyset$
        \State Si no he recibido algún mensaje
        \If{$PADRE == \bot$}
            \State $LIDER = ID$ 
            \State $send(<BFS,ID,LIDER>)$ a todos mis vecinos
            \State $PADRE = ID$
        \EndIf 


        \State Al recibir $<BFS,ID, LIDER>$ desde el vecino $p_j$

        \If{$PADRE == \bot$}
            \State $PADRE = j$
            \State $mensajes=\{<L_1>,<L_2>,\dots,<L_d>\} \cup LIDER$
            \State $LIDER = max(mensajes)$
            
            \State $send(<parent,LIDER>)$ a $p_j$
            \State $send(<BFS,ID, LIDER>)$ a todos excepto $p_j$
        \Else
            \State $send(<already, LIDER>)$ a $p_j$
        \EndIf


        \State Al recibir $<parent,LIDER>$ dede el vecino $p_j$
        \State $mensajes=\{<L_1>,<L_2>,\dots,<L_d>\} \cup LIDER$
        \State $LIDER = max(mensajes)$
        \State $HIJOS = HIJOS \cup \{p_j\}$
        \State $send(<LIDER)$ a todos en HIJOS

        \If{$HIJOS \cup OTROS == VECINOS-PADRE$}
            \State \textbf{Terminar}
        \EndIf

        \State Al recibir $<already, LIDER>$ desde $p_j$
        \State $OTROS = OTROS \cup \{p_j\}$
        \State $mensajes=\{<L_1>,<L_2>,\dots,<L_d>\} \cup LIDER$
        \State $LIDER = max(mensajes)$
        \State $send(<LIDER>)$ a todos en HIJOS

        \If{$HIJOS \cup OTROS == VECINOS-PADRE$}
            \State \textbf{Terminar}
        \EndIf

        \State Al recibir $<LIDER>$ desde $p_j$
        \State $LIDER = <LIDER>$
        \State $send(<LIDER>)$ a HIJOS

    \end{algorithmic}
\end{algorithm}    


Muestra que el algoritmo es correcto.
Podemos describir la ejecución del algoritmo como sigue:
Al principio de la ejecución cualquier nodo que se tome al principio será el lider y la raíz del árbol BFS. Luego le envia $<BFS,ID,LIDER>$ a todos sus vecinos, los cuales si no tienen PADRE asigna $p_j$ como su padre y determinan el LIDER (el maximo de los mensajes $<LIDER>$ que ha recibido), lo asigna como su LIDER, le envia a $p_j$ un mensaje que lo asigna como su padre y le dice el nuevo LIDER, cuando el PADRE recibe el mensaje añade el nodo al conjunto de sus hijos, calcula nuevamente el LIDER y se lo envia a sus HIJOS. Los cuales registran su nuevo LIDER. Si el nodo ya tiene PADRE entonces envian el mensaje $<already,LIDER>$ al nodo $p_j$, el cual calcula nuevamente el LIDER y se lo comunica a sus hijos.

El último segmento lineas 33-35 termina cuando el nodo ya no tiene hijos.

\textbf{Afirmación}: El algoritmo {\tt arbolGeneradorID} es correcto, es decir, cumple con las propiedades de validez y acuerdo. Además construye un árbol con raiz.

\textbf{Acuerdo.} Todos los procesos acuerdan un mismo valor.

Al terminar cualesquiera 2 procesos $p_i$ y $p_j$ con variables $LIDER_i$ y $LIDER_j$, se cumple que $LIDER_i=LIDER_j$ Observemos que para todo tiempo $d>0$, todos los procesos que están a distancia a lo más $d$ del proceso con el ID máximo, tiene ese ID en la variable LIDER.

\textbf{Por inducción sobre d:}

\textbf{Caso base:} $d=0$. Es claro que $LIDER=ID$ para el proceso con el ID máximo.

\textbf{Hipótesis de inducción:} Para todo proceso a distancia $d-1$ del proceso con ID maximo tiene dicho $ID$ en su variable LIDER.

\textbf{Paso inductivo:}
Consideremos un proceso $p_i$ a distancia $d$ del proceso con el ID máximo. A partir de la H.I, sabemos que existe un proceso $p_j$ a distancia $d-1$ del proceso con ID máximo con $LIDER = ID.p_j$ vecino de $P_i$
Ejecutando el algoritmo


\textbf{Validez.} Al terminar el algoritmo todos los procesos tienen como LIDER un ID que fue entrada de algún proceso.

Al terminar todo proceso tiene como LIDER un ID que fue entrada de algún proceso. Esto es fácil de observar, ya que $LIDER=max(mensajes)$ y esto es construido a partir de las propuestas de los vecinos.


Compara la complejidad de tiempo respecto al algoritmo anterior.

En este caso el algortimo hace a BFS al mismo tiempo que elige un lider por lo que tarda la máxima distancia entre el LIDER y cualquier vértice de la gráfica, es decir, su complejidad de tiempo es $O(diam(G))$